---
title: 第四章：基于tpc的服务端客户端（1）
date: 2077-07-26
sidebar: auto
article: false
---

## 4.1 理解TCP和UDP

TCP（Transmission Control Protocol）是“对数据传输过程控制”的缩写。

TCP协议栈分为四层：应用层 <-> TCP层 <-> IP层 <-> 链路层

UDP协议栈分为四层：应用层 <-> UDP层 <-> IP层 <-> 链路层

- 链路层：定义网络环境的连接结构；
- IP层：只关注单包数据的传输，不关心顺序与正确与否；
- TCP/UDP层：通过协议规范传输顺序与正确性校验；
- 应用层：决定什么时候传输怎么样的数据（网络编程的工作）；



## 4.2 实现基于TCP的服务端/客户端

### 实现顺序

客户端：

1. socket()：创建套接字
2. bind()：分配地址端口
3. listen()：进入等待连接状态
4. accept()：允许连接
5. read()/write()：传输数据
6. close()：关闭连接

服务端：

1. socket()：创建套接字
2. connect()：请求连接
3. read()/write()：传输数据
4. close()：关闭连接

### 进入等待请求状态

```c++
#include <sys/socket.h>
int listen(int sock, int backlog);
// 成功时返回0，失败时返回-1。
```

-sock：服务端进入连接状态的套接字；

-backlog：连接等待队列（Queue）的长度；

当上一个请求没有被处理完成，其他的请求会进入等待队列。backlog 参数决定了队列的最大长度是多少，当队列满后多余的请求将无法被侦听。对于请求频繁的Web服务器队列长度一般至少为15，具体长度取决于应用场景。

### 接受客户端连接请求

```c++
#include <sys/socket.h>
int accept(int sock, struct sockaddr *addr, socklen_t *addrlen);
// 成功时返回创建的套接字文件描述符，失败时返回-1。
```

-sock：服务端套接字文件描述符；

-addr：用于保存客户端的地址信息；

-addrlen：客户端地址长度；

该函数会为连接请求创建一个连接客户端的套接字，数据的收发是通过这里创建的新的套接字进行的，而不是刚刚的服务端套接字。

### 客户端发起连接

```c++
#include <sys/socket.h>
int connect(int sock, struct sockaddr *servaddr, socklen_t addrlen);
// 成功时返回0，失败时返回-1。
```

-sock：客户端套接字文件描述符；

-servaddr：目标服务端地址信息；

-addrlen ：服务端地址长度；

只有在连接成功进入队列（Queue）或者遇到断网等异常中断时 connect() 函数才会返回结果。

## 4.3 实现迭代服务端/客户端

详见对应源代码

## 4.4 基于Windows实现



## 4.5 习题

为何需要把TCP/IP协议栈分成4层（或7层）？结合开放式系统回答。

> 把协议分成多个层次，除了可以使协议设计更加容易以外，更重要的原因是，为了通过标准化操作设计开放式系统。
>
> 标准本身就在于对外公开，引导更多的人遵守规范。从而使得人们生活更加方便，不用为了不同的标准、协议而大费周折。
>
> 比如，路由器同来完成IP层交互任务。某公司原来使用A公司的路由器，先要将其替换成B公司的，因为统一了标准，所有生产商都按照IP层标准制造，所以更换起来非常方便。